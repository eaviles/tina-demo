{"ast":null,"code":"import { Vector3, BufferAttribute, Box3 } from 'three';\nimport { CENTER } from './Constants.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG, buildPackedTree } from './buildFunctions.js';\nimport { OrientedBox } from './Utils/OrientedBox.js';\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\nimport { setTriangle } from './Utils/TriangleUtils.js';\nimport { raycast, raycastFirst, shapecast, intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { arrayToBox, iterateOverTriangles } from './Utils/BufferNodeUtils.js';\nconst SKIP_GENERATION = Symbol('skip tree generation');\nconst obb = new OrientedBox();\nconst obb2 = new OrientedBox();\nconst temp = new Vector3();\nconst temp1 = new Vector3();\nconst temp2 = new Vector3();\nconst tempBox = new Box3();\nconst triangle = new SeparatingAxisTriangle();\nconst triangle2 = new SeparatingAxisTriangle();\nexport default class MeshBVH {\n  static serialize(bvh, geometry, copyIndexBuffer = true) {\n    const rootData = bvh._roots;\n    const indexAttribute = geometry.getIndex();\n    const result = {\n      roots: rootData,\n      index: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array\n    };\n    return result;\n  }\n\n  static deserialize(data, geometry, setIndex = true) {\n    const {\n      index,\n      roots\n    } = data;\n    const bvh = new MeshBVH(geometry, {\n      [SKIP_GENERATION]: true\n    });\n    bvh._roots = roots;\n\n    if (setIndex) {\n      const indexAttribute = geometry.getIndex();\n\n      if (indexAttribute === null) {\n        const newIndex = new BufferAttribute(data.index, 1, false);\n        geometry.setIndex(newIndex);\n      } else if (indexAttribute.array !== index) {\n        indexAttribute.array.set(index);\n        indexAttribute.needsUpdate = true;\n      }\n    }\n\n    return bvh;\n  }\n\n  constructor(geometry, options = {}) {\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      setBoundingBox: true,\n      // undocumented options\n      // Whether to skip generating the tree. Used for deserialization.\n      [SKIP_GENERATION]: false\n    }, options);\n    options.strategy = Math.max(0, Math.min(2, options.strategy));\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  refit(nodeIndices = null, terminationIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n      nodeIndices = new Set(nodeIndices);\n    }\n\n    if (terminationIndices && Array.isArray(terminationIndices)) {\n      terminationIndices = new Set(terminationIndices);\n    }\n\n    const geometry = this.geometry;\n    const indexArr = geometry.index.array;\n    const posAttr = geometry.attributes.position;\n    const posArr = posAttr.array; // support for an interleaved position buffer\n\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n\n    if (posAttr.isInterleavedBufferAttribute) {\n      stride = posAttr.data.stride;\n    }\n\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = this._roots;\n\n    for (let i = 0, l = roots.length; i < l; i++) {\n      buffer = roots[i];\n      uint32Array = new Uint32Array(buffer);\n      uint16Array = new Uint16Array(buffer);\n      float32Array = new Float32Array(buffer);\n\n      _traverse(0, byteOffset);\n\n      byteOffset += buffer.byteLength;\n    }\n\n    function _traverse(node32Index, byteOffset, force = false) {\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        let minx = Infinity;\n        let miny = Infinity;\n        let minz = Infinity;\n        let maxx = -Infinity;\n        let maxy = -Infinity;\n        let maxz = -Infinity;\n\n        for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {\n          const index = indexArr[i] * stride + bufferOffset;\n          const x = posArr[index + 0];\n          const y = posArr[index + 1];\n          const z = posArr[index + 2];\n          if (x < minx) minx = x;\n          if (x > maxx) maxx = x;\n          if (y < miny) miny = y;\n          if (y > maxy) maxy = y;\n          if (z < minz) minz = z;\n          if (z > maxz) maxz = z;\n        }\n\n        if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n          float32Array[node32Index + 0] = minx;\n          float32Array[node32Index + 1] = miny;\n          float32Array[node32Index + 2] = minz;\n          float32Array[node32Index + 3] = maxx;\n          float32Array[node32Index + 4] = maxy;\n          float32Array[node32Index + 5] = maxz;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        const left = node32Index + 8;\n        const right = uint32Array[node32Index + 6]; // the indentifying node indices provided by the shapecast function include offsets of all\n        // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n        const offsetLeft = left + byteOffset;\n        const offsetRight = right + byteOffset;\n        let leftChange = false;\n        let forceLeft = force || terminationIndices && terminationIndices.has(offsetLeft);\n        let traverseLeft = forceLeft || (nodeIndices ? nodeIndices.has(offsetLeft) : true);\n\n        if (traverseLeft) {\n          leftChange = _traverse(left, byteOffset, forceLeft);\n        }\n\n        let rightChange = false;\n        let forceRight = force || terminationIndices && terminationIndices.has(offsetRight);\n        let traverseRight = forceRight || (nodeIndices ? nodeIndices.has(offsetRight) : true);\n\n        if (traverseRight) {\n          rightChange = _traverse(right, byteOffset, forceRight);\n        }\n\n        const didChange = leftChange || rightChange;\n\n        if (didChange) {\n          for (let i = 0; i < 3; i++) {\n            const lefti = left + i;\n            const righti = right + i;\n            const minLeftValue = float32Array[lefti];\n            const maxLeftValue = float32Array[lefti + 3];\n            const minRightValue = float32Array[righti];\n            const maxRightValue = float32Array[righti + 3];\n            float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n            float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n          }\n        }\n\n        return didChange;\n      }\n    }\n  }\n\n  traverse(callback, rootIndex = 0) {\n    const buffer = this._roots[rootIndex];\n    const uint32Array = new Uint32Array(buffer);\n    const uint16Array = new Uint16Array(buffer);\n\n    _traverse(0);\n\n    function _traverse(node32Index, depth = 0) {\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n      } else {\n        const left = node32Index + BYTES_PER_NODE / 4;\n        const right = uint32Array[node32Index + 6];\n        const splitAxis = uint32Array[node32Index + 7];\n        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n        if (!stopTraversal) {\n          _traverse(left, depth + 1);\n\n          _traverse(right, depth + 1);\n        }\n      }\n    }\n  }\n  /* Core Cast Functions */\n\n\n  raycast(mesh, raycaster, ray, intersects) {\n    const geometry = this.geometry;\n    const localIntersects = intersects ? [] : null;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      raycast(0, mesh, geometry, raycaster, ray, localIntersects);\n      clearBuffer();\n    }\n\n    if (intersects) {\n      for (let i = 0, l = localIntersects.length; i < l; i++) {\n        delete localIntersects[i].localPoint;\n      }\n\n      intersects.push(...localIntersects);\n    }\n  }\n\n  raycastFirst(mesh, raycaster, ray) {\n    const geometry = this.geometry;\n    let closestResult = null;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      const result = raycastFirst(0, mesh, geometry, raycaster, ray);\n      clearBuffer();\n\n      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n        closestResult = result;\n      }\n    }\n\n    if (closestResult) {\n      delete closestResult.localPoint;\n    }\n\n    return closestResult;\n  }\n\n  intersectsGeometry(mesh, otherGeometry, geomToMesh) {\n    const geometry = this.geometry;\n    let result = false;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = intersectsGeometry(0, mesh, geometry, otherGeometry, geomToMesh);\n      clearBuffer();\n\n      if (result) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  shapecast(mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n    const geometry = this.geometry;\n\n    if (callbacks instanceof Function) {\n      if (_intersectsTriangleFunc) {\n        // Support the previous function signature that provided three sequential index buffer\n        // indices here.\n        const originalTriangleFunc = _intersectsTriangleFunc;\n\n        _intersectsTriangleFunc = (tri, index, contained, depth) => {\n          const i3 = index * 3;\n          return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n        };\n      }\n\n      callbacks = {\n        boundsTraverseOrder: _orderNodesFunc,\n        intersectsBounds: callbacks,\n        intersectsTriangle: _intersectsTriangleFunc,\n        intersectsRange: null\n      };\n      console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n    }\n\n    let {\n      boundsTraverseOrder,\n      intersectsBounds,\n      intersectsRange,\n      intersectsTriangle\n    } = callbacks;\n\n    if (intersectsRange && intersectsTriangle) {\n      const originalIntersectsRange = intersectsRange;\n\n      intersectsRange = (offset, count, contained, depth, nodeIndex) => {\n        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        }\n\n        return true;\n      };\n    } else if (!intersectsRange) {\n      if (intersectsTriangle) {\n        intersectsRange = (offset, count, contained, depth) => {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        };\n      } else {\n        intersectsRange = (offset, count, contained) => {\n          return contained;\n        };\n      }\n    }\n\n    let result = false;\n    let byteOffset = 0;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n      clearBuffer();\n\n      if (result) {\n        break;\n      }\n\n      byteOffset += root.byteLength;\n    }\n\n    return result;\n  }\n  /* Derived Cast Functions */\n\n\n  intersectsBox(mesh, box, boxToMesh) {\n    obb.set(box.min, box.max, boxToMesh);\n    obb.needsUpdate = true;\n    return this.shapecast(mesh, {\n      intersectsBounds: box => obb.intersectsBox(box),\n      intersectsTriangle: tri => obb.intersectsTriangle(tri)\n    });\n  }\n\n  intersectsSphere(mesh, sphere) {\n    return this.shapecast(mesh, {\n      intersectsBounds: box => sphere.intersectsBox(box),\n      intersectsTriangle: tri => tri.intersectsSphere(sphere)\n    });\n  }\n\n  closestPointToGeometry(mesh, otherGeometry, geometryToBvh, target1 = null, target2 = null, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) {\n      otherGeometry.computeBoundingBox();\n    }\n\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = this.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    let tempTarget1 = null;\n    let tempTarget2 = null;\n\n    if (target1) {\n      tempTarget1 = temp1;\n    }\n\n    if (target2) {\n      tempTarget2 = temp2;\n    }\n\n    let closestDistance = Infinity;\n    obb2.matrix.copy(geometryToBvh).invert();\n    this.shapecast(mesh, {\n      boundsTraverseOrder: box => {\n        return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        if (score < closestDistance && score < maxThreshold) {\n          // if we know the triangles of this bounds will be intersected next then\n          // save the bounds to use during triangle checks.\n          if (isLeaf) {\n            obb2.min.copy(box.min);\n            obb2.max.copy(box.max);\n            obb2.needsUpdate = true;\n          }\n\n          return true;\n        }\n\n        return false;\n      },\n      intersectsRange: (offset, count) => {\n        if (otherGeometry.boundsTree) {\n          // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n          // the closest bounds in the other geometry to check.\n          return otherGeometry.boundsTree.shapecast(null, {\n            boundsTraverseOrder: box => {\n              return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n            },\n            intersectsBounds: (box, isLeaf, score) => {\n              return score < closestDistance && score < maxThreshold;\n            },\n            intersectsRange: (otherOffset, otherCount) => {\n              for (let i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                setTriangle(triangle2, i2, otherIndex, otherPos);\n                triangle2.a.applyMatrix4(geometryToBvh);\n                triangle2.b.applyMatrix4(geometryToBvh);\n                triangle2.c.applyMatrix4(geometryToBvh);\n                triangle2.needsUpdate = true;\n\n                for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                  setTriangle(triangle, i, index, pos);\n                  triangle.needsUpdate = true;\n                  const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                  if (dist < closestDistance) {\n                    if (target1) {\n                      target1.copy(tempTarget1);\n                    }\n\n                    if (target2) {\n                      target2.copy(tempTarget2);\n                    }\n\n                    closestDistance = dist;\n                  } // stop traversal if we find a point that's under the given threshold\n\n\n                  if (dist < minThreshold) {\n                    return true;\n                  }\n                }\n              }\n            }\n          });\n        } else {\n          // If no bounds tree then we'll just check every triangle.\n          const triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n          for (let i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, otherIndex, otherPos);\n            triangle2.a.applyMatrix4(geometryToBvh);\n            triangle2.b.applyMatrix4(geometryToBvh);\n            triangle2.c.applyMatrix4(geometryToBvh);\n            triangle2.needsUpdate = true;\n\n            for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n              setTriangle(triangle, i, index, pos);\n              triangle.needsUpdate = true;\n              const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n              if (dist < closestDistance) {\n                if (target1) {\n                  target1.copy(tempTarget1);\n                }\n\n                if (target2) {\n                  target2.copy(tempTarget2);\n                }\n\n                closestDistance = dist;\n              } // stop traversal if we find a point that's under the given threshold\n\n\n              if (dist < minThreshold) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    });\n    return closestDistance;\n  }\n\n  distanceToGeometry(mesh, geom, matrix, minThreshold, maxThreshold) {\n    return this.closestPointToGeometry(mesh, geom, matrix, null, null, minThreshold, maxThreshold);\n  }\n\n  closestPointToPoint(mesh, point, target, minThreshold = 0, maxThreshold = Infinity) {\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    this.shapecast(mesh, {\n      boundsTraverseOrder: box => {\n        temp.copy(point).clamp(box.min, box.max);\n        return temp.distanceToSquared(point);\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        return score < closestDistanceSq && score < maxThresholdSq;\n      },\n      intersectsTriangle: tri => {\n        tri.closestPointToPoint(point, temp);\n        const distSq = point.distanceToSquared(temp);\n\n        if (distSq < closestDistanceSq) {\n          if (target) {\n            target.copy(temp);\n          }\n\n          closestDistanceSq = distSq;\n        }\n\n        if (distSq < minThresholdSq) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    });\n    return Math.sqrt(closestDistanceSq);\n  }\n\n  distanceToPoint(mesh, point, minThreshold, maxThreshold) {\n    return this.closestPointToPoint(mesh, point, null, minThreshold, maxThreshold);\n  }\n\n  getBoundingBox(target) {\n    target.makeEmpty();\n    const roots = this._roots;\n    roots.forEach(buffer => {\n      arrayToBox(0, new Float32Array(buffer), tempBox);\n      target.union(tempBox);\n    });\n    return target;\n  }\n\n}","map":{"version":3,"sources":["/Users/alisablakeney/coding/websites/longest-hum/client/node_modules/three-mesh-bvh/src/MeshBVH.js"],"names":["Vector3","BufferAttribute","Box3","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","OrientedBox","SeparatingAxisTriangle","setTriangle","raycast","raycastFirst","shapecast","intersectsGeometry","setBuffer","clearBuffer","arrayToBox","iterateOverTriangles","SKIP_GENERATION","Symbol","obb","obb2","temp","temp1","temp2","tempBox","triangle","triangle2","MeshBVH","serialize","bvh","geometry","copyIndexBuffer","rootData","_roots","indexAttribute","getIndex","result","roots","index","array","slice","deserialize","data","setIndex","newIndex","set","needsUpdate","constructor","options","isBufferGeometry","Error","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","setBoundingBox","Math","max","min","boundingBox","getBoundingBox","refit","nodeIndices","terminationIndices","Array","isArray","Set","indexArr","posAttr","attributes","position","posArr","bufferOffset","offset","stride","buffer","uint32Array","uint16Array","float32Array","byteOffset","i","l","length","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","count","minx","Infinity","miny","minz","maxx","maxy","maxz","x","y","z","left","right","offsetLeft","offsetRight","leftChange","forceLeft","has","traverseLeft","rightChange","forceRight","traverseRight","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","depth","splitAxis","stopTraversal","mesh","raycaster","ray","intersects","localIntersects","root","localPoint","push","closestResult","distance","otherGeometry","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","console","warn","originalIntersectsRange","nodeIndex","intersectsBox","box","boxToMesh","intersectsSphere","sphere","closestPointToGeometry","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTarget2","closestDistance","matrix","copy","invert","distanceToBox","score","boundsTree","otherOffset","otherCount","i2","l2","a","applyMatrix4","b","c","dist","distanceToTriangle","triCount","distanceToGeometry","geom","closestPointToPoint","point","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","distSq","sqrt","distanceToPoint","makeEmpty","forEach","union"],"mappings":"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","sourcesContent":["import { Vector3, BufferAttribute, Box3 } from 'three';\r\nimport { CENTER } from './Constants.js';\r\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG, buildPackedTree } from './buildFunctions.js';\r\nimport { OrientedBox } from './Utils/OrientedBox.js';\r\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\r\nimport { setTriangle } from './Utils/TriangleUtils.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { arrayToBox, iterateOverTriangles } from './Utils/BufferNodeUtils.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst obb = new OrientedBox();\r\nconst obb2 = new OrientedBox();\r\nconst temp = new Vector3();\r\nconst temp1 = new Vector3();\r\nconst temp2 = new Vector3();\r\nconst tempBox = new Box3();\r\nconst triangle = new SeparatingAxisTriangle();\r\nconst triangle2 = new SeparatingAxisTriangle();\r\n\r\nexport default class MeshBVH {\r\n\r\n\tstatic serialize( bvh, geometry, copyIndexBuffer = true ) {\r\n\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tconst result = {\r\n\t\t\troots: rootData,\r\n\t\t\tindex: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array,\r\n\t\t};\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, setIndex = true ) {\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\r\n\t\t\tsetBoundingBox: true,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false\r\n\r\n\t\t}, options );\r\n\t\toptions.strategy = Math.max( 0, Math.min( 2, options.strategy ) );\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null, terminationIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tif ( terminationIndices && Array.isArray( terminationIndices ) ) {\r\n\r\n\t\t\tterminationIndices = new Set( terminationIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\t\tconst posArr = posAttr.array;\r\n\r\n\t\t// support for an interleaved position buffer\r\n\t\tconst bufferOffset = posAttr.offset || 0;\r\n\t\tlet stride = 3;\r\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tstride = posAttr.data.stride;\r\n\r\n\t\t}\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\r\n\t\t\t\t\tconst x = posArr[ index + 0 ];\r\n\t\t\t\t\tconst y = posArr[ index + 1 ];\r\n\t\t\t\t\tconst z = posArr[ index + 2 ];\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the indentifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tlet forceLeft = force || terminationIndices && terminationIndices.has( offsetLeft );\r\n\t\t\t\tlet traverseLeft = forceLeft || ( nodeIndices ? nodeIndices.has( offsetLeft ) : true );\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceLeft );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tlet forceRight = force || terminationIndices && terminationIndices.has( offsetRight );\r\n\t\t\t\tlet traverseRight = forceRight || ( nodeIndices ? nodeIndices.has( offsetRight ) : true );\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceRight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( mesh, raycaster, ray, intersects ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst localIntersects = intersects ? [] : null;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\traycast( 0, mesh, geometry, raycaster, ray, localIntersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t}\r\n\r\n\t\tif ( intersects ) {\r\n\r\n\t\t\tfor ( let i = 0, l = localIntersects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tdelete localIntersects[ i ].localPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.push( ...localIntersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycastFirst( mesh, raycaster, ray ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet closestResult = null;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tconst result = raycastFirst( 0, mesh, geometry, raycaster, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( closestResult ) {\r\n\r\n\t\t\tdelete closestResult.localPoint;\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( mesh, otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, mesh, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( mesh, box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( mesh, sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( mesh, otherGeometry, geometryToBvh, target1 = null, target2 = null, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\r\n\t\tlet tempTarget1 = null;\r\n\t\tlet tempTarget2 = null;\r\n\t\tif ( target1 ) {\r\n\r\n\t\t\ttempTarget1 = temp1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp2;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tobb2.matrix.copy( geometryToBvh ).invert();\r\n\t\tthis.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box, Math.min( closestDistance, maxThreshold ) );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast(\r\n\t\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box, Math.min( closestDistance, maxThreshold ) );\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( target1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( target2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( target1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttarget1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif ( target2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttarget2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t}\r\n\r\n\tdistanceToGeometry( mesh, geom, matrix, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToGeometry( mesh, geom, matrix, null, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( mesh, point, target, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\t\t\ttarget.copy( temp );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( mesh, point, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToPoint( mesh, point, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}